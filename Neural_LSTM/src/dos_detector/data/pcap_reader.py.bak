#src/dos_detector/data/pcap_reader.py

"""PCAP reading utilities."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterator, List, Optional

from scapy.all import ICMP, IP, IPv6, RawPcapReader, TCP, UDP, Ether

from .structures import PacketRecord


@dataclass
class PCAPMetadata:
    """Basic metadata about a PCAP file."""

    path: Path
    packet_count: int
    duration: float
    start_time: float
    end_time: float


def _extract_timestamp(ts_sec: int, ts_usec: int) -> float:
    return float(ts_sec) + float(ts_usec) / 1_000_000.0


def _decode_packet(data: bytes, timestamp: float) -> Optional[PacketRecord]:
    packet = Ether(data)
    src_mac = packet.src if hasattr(packet, "src") else None
    dst_mac = packet.dst if hasattr(packet, "dst") else None

    ip_layer = packet.getlayer(IP) or packet.getlayer(IPv6)
    src_ip: Optional[str] = None
    dst_ip: Optional[str] = None
    ttl: Optional[int] = None
    protocol = "other"
    src_port: Optional[int] = None
    dst_port: Optional[int] = None
    tcp_flags: Optional[int] = None
    payload_len = 0
    info: dict[str, Optional[str]] = {}

    if ip_layer is not None:
        src_ip = getattr(ip_layer, "src", None)
        dst_ip = getattr(ip_layer, "dst", None)
        ttl = getattr(ip_layer, "ttl", getattr(ip_layer, "hlim", None))

        if ip_layer.haslayer(TCP):
            tcp_layer = ip_layer.getlayer(TCP)
            src_port = int(tcp_layer.sport)
            dst_port = int(tcp_layer.dport)
            tcp_flags = int(tcp_layer.flags)
            protocol = "tcp"
            payload_len = len(bytes(tcp_layer.payload))
        elif ip_layer.haslayer(UDP):
            udp_layer = ip_layer.getlayer(UDP)
            src_port = int(udp_layer.sport)
            dst_port = int(udp_layer.dport)
            protocol = "udp"
            payload_len = len(bytes(udp_layer.payload))
            if payload_len:
                payload = bytes(udp_layer.payload).decode(errors="ignore")
                if "M-SEARCH" in payload:
                    info["ssdp_method"] = "M-SEARCH"
                elif "NOTIFY" in payload:
                    info["ssdp_method"] = "NOTIFY"
        elif ip_layer.haslayer(ICMP):
            icmp_layer = ip_layer.getlayer(ICMP)
            protocol = "icmp"
            info["icmp_type"] = str(getattr(icmp_layer, "type", None))
            payload_len = len(bytes(icmp_layer.payload))
        else:
            payload_len = len(bytes(ip_layer.payload))
            protocol = ip_layer.name.lower()
    else:
        payload_len = len(bytes(packet.payload))

    return PacketRecord(
        timestamp=timestamp,
        src_mac=src_mac,
        dst_mac=dst_mac,
        src_ip=src_ip,
        dst_ip=dst_ip,
        src_port=src_port,
        dst_port=dst_port,
        protocol=protocol,
        length=len(packet),
        ttl=ttl,
        tcp_flags=tcp_flags,
        payload_len=payload_len,
        info=info,
    )


def read_pcap(path: Path, limit: Optional[int] = None) -> List[PacketRecord]:
    """Read a PCAP into a list of :class:`PacketRecord`."""

    packets: List[PacketRecord] = []
    reader = RawPcapReader(str(path))
    for index, (data, metadata) in enumerate(reader):
        if limit is not None and index >= limit:
            break
        timestamp = _extract_timestamp(metadata.sec, metadata.usec)
        decoded = _decode_packet(data, timestamp)
        if decoded is not None:
            packets.append(decoded)
    reader.close()
    return packets


def iter_pcap(path: Path) -> Iterator[PacketRecord]:
    """Stream packets from a PCAP file."""

    reader = RawPcapReader(str(path))
    try:
        for data, metadata in reader:
            timestamp = _extract_timestamp(metadata.sec, metadata.usec)
            decoded = _decode_packet(data, timestamp)
            if decoded is not None:
                yield decoded
    finally:
        reader.close()


def summarize_packets(packets: List[PacketRecord], path: Path) -> PCAPMetadata:
    if not packets:
        return PCAPMetadata(path=path, packet_count=0, duration=0.0, start_time=0.0, end_time=0.0)
    start = packets[0].timestamp
    end = packets[-1].timestamp
    return PCAPMetadata(
        path=path,
        packet_count=len(packets),
        duration=end - start,
        start_time=start,
        end_time=end,
    )